// AUTOGENERATED FILE
// This file was generated from ohm-grammar.ohm by `ohm generateBundles`.

import {
  BaseActionDict,
  Grammar,
  IterationNode,
  Node,
  NonterminalNode,
  Semantics,
  TerminalNode
} from 'ohm-js';

export interface OhmActionDict<T> extends BaseActionDict<T> {
  Grammars?: (this: NonterminalNode, arg0: IterationNode) => T;
  Grammar?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode, arg2: TerminalNode, arg3: IterationNode, arg4: TerminalNode) => T;
  SuperGrammar?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  Rule_define?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode, arg2: IterationNode, arg3: TerminalNode, arg4: NonterminalNode) => T;
  Rule_override?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode, arg2: TerminalNode, arg3: NonterminalNode) => T;
  Rule_extend?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode, arg2: TerminalNode, arg3: NonterminalNode) => T;
  Rule?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  RuleBody?: (this: NonterminalNode, arg0: IterationNode, arg1: NonterminalNode) => T;
  TopLevelTerm_inline?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
  TopLevelTerm?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  OverrideRuleBody?: (this: NonterminalNode, arg0: IterationNode, arg1: NonterminalNode) => T;
  OverrideTopLevelTerm_superSplice?: (this: NonterminalNode, arg0: TerminalNode) => T;
  OverrideTopLevelTerm?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Formals?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
  Params?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
  Alt?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Seq?: (this: NonterminalNode, arg0: IterationNode) => T;
  Iter_star?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode) => T;
  Iter_plus?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode) => T;
  Iter_opt?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode) => T;
  Iter?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Pred_not?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  Pred_lookahead?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  Pred?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Lex_lex?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  Lex?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Base_application?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;
  Base_range?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  Base_terminal?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Base_paren?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
  Base?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ruleDescr?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
  ruleDescrText?: (this: NonterminalNode, arg0: IterationNode) => T;
  caseName?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: NonterminalNode, arg3: IterationNode, arg4: TerminalNode) => T;
  name?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;
  nameFirst?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  nameRest?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  ident?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  terminal?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
  oneCharTerminal?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
  terminalChar?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  escapeChar_backslash?: (this: NonterminalNode, arg0: TerminalNode) => T;
  escapeChar_doubleQuote?: (this: NonterminalNode, arg0: TerminalNode) => T;
  escapeChar_singleQuote?: (this: NonterminalNode, arg0: TerminalNode) => T;
  escapeChar_backspace?: (this: NonterminalNode, arg0: TerminalNode) => T;
  escapeChar_lineFeed?: (this: NonterminalNode, arg0: TerminalNode) => T;
  escapeChar_carriageReturn?: (this: NonterminalNode, arg0: TerminalNode) => T;
  escapeChar_tab?: (this: NonterminalNode, arg0: TerminalNode) => T;
  escapeChar_unicodeCodePoint?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: IterationNode, arg4: IterationNode, arg5: IterationNode, arg6: IterationNode, arg7: TerminalNode) => T;
  escapeChar_unicodeEscape?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: NonterminalNode, arg4: NonterminalNode) => T;
  escapeChar_hexEscape?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
  escapeChar?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  space?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  comment_singleLine?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: NonterminalNode | TerminalNode) => T;
  comment_multiLine?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
  comment?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  tokens?: (this: NonterminalNode, arg0: IterationNode) => T;
  token?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  operator?: (this: NonterminalNode, arg0: TerminalNode) => T;
  punctuation?: (this: NonterminalNode, arg0: TerminalNode) => T;
}

export interface OhmSemantics extends Semantics {
  addOperation<T>(name: string, actionDict: OhmActionDict<T>): this;
  extendOperation<T>(name: string, actionDict: OhmActionDict<T>): this;
  addAttribute<T>(name: string, actionDict: OhmActionDict<T>): this;
  extendAttribute<T>(name: string, actionDict: OhmActionDict<T>): this;
}

export interface OhmGrammar extends Grammar {
  createSemantics(): OhmSemantics;
  extendSemantics(superSemantics: OhmSemantics): OhmSemantics;
}

declare const grammar: OhmGrammar;
export default grammar;

